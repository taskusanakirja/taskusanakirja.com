{{ define "main" }}
<!-- Hero Section with 3D Book -->
<section class="flex items-center justify-center" style="min-height: min(100vh, 900px);">
    <div class="container mx-auto px-6">
        <div class="flex flex-col md:flex-row items-center justify-center gap-8 md:gap-12">
            <!-- 3D Book Container (Left) -->
            <div class="relative w-80 h-80">
                <div id="book-canvas" class="w-full h-full cursor-move"></div>
                <!-- Interactive hint -->
                <div id="drag-hint" class="absolute bottom-0 left-0 right-0 text-center text-sm text-slate-600 italic">
                    Drag to rotate • Scroll to zoom • Click to open
                </div>
            </div>
            
            <!-- Text Content (Right) -->
            <div class="max-w-lg text-center md:text-left">
                <h1 class="text-3xl md:text-4xl lg:text-5xl font-display font-bold text-ink-900 mb-4 leading-tight">
                    The Architecture of Taskusanakirja
                </h1>
                <p class="text-lg text-ink-700 font-serif mb-8">
                    A free technical ebook exploring the design and implementation of a terminal-based Finnish-English dictionary
                </p>
                
                <!-- Download Buttons -->
                <div class="flex flex-wrap gap-4 justify-center md:justify-start">
                    <a href="#chapters" class="btn-primary inline-flex items-center justify-center px-6 py-3">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                        </svg>
                        Read Online
                    </a>
                    
                    <button disabled class="btn-secondary inline-flex items-center justify-center px-6 py-3 opacity-50 cursor-not-allowed">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                        </svg>
                        PDF (Coming Soon)
                    </button>
                    
                    <button disabled class="btn-secondary inline-flex items-center justify-center px-6 py-3 opacity-50 cursor-not-allowed">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        EPUB (Coming Soon)
                    </button>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- Chapters Section (Below the Fold) -->
<section id="chapters" class="py-20 bg-ochre-50 border-t-2 border-ochre-200">
    <div class="container mx-auto px-6 max-w-4xl">
        <article class="prose prose-slate prose-lg mx-auto">
            <h2 class="font-display text-3xl mb-8">Table of Contents</h2>
            
            {{ .Content }}
            
            <div class="mt-12">
                <h3 class="font-display text-2xl mb-6">Chapters</h3>
                <div class="space-y-4">
                    {{ range .Pages.ByWeight }}
                    <div class="border-l-4 border-ochre pl-4 py-2 hover:bg-parchment transition-colors">
                        <a href="{{ .Permalink }}" class="no-underline">
                            <h4 class="text-xl font-display mb-1 text-burgundy hover:text-ochre-dark">
                                Chapter {{ .Params.chapter }}: {{ .Title }}
                            </h4>
                            {{ if .Description }}
                            <p class="text-slate-600 text-base">{{ .Description }}</p>
                            {{ end }}
                        </a>
                    </div>
                    {{ end }}
                </div>
            </div>
        </article>
    </div>
</section>

<!-- Three.js Script -->
<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

console.log('Three.js module loaded:', typeof THREE !== 'undefined');

// Initialize Three.js scene for the book
function init() {
    try {
    const container = document.getElementById('book-canvas');
    if (!container) {
        console.error('book-canvas container not found!');
        return;
    }
    
    console.log('Initializing 3D book...');
    const width = container.clientWidth || 320;
    const height = container.clientHeight || 320;
    console.log('Container dimensions:', width, 'x', height);
    
    if (width === 0 || height === 0) {
        console.error('Container has zero dimensions, using default 320x320');
        container.style.width = '320px';
        container.style.height = '320px';
    }

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = null; // Transparent background

    // Camera setup
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(2, 1, 4);
    camera.lookAt(0, 0, 0);

    // Renderer setup with shadows
    const renderer = new THREE.WebGLRenderer({ 
        alpha: true, 
        antialias: true,
        powerPreference: "high-performance"
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    container.appendChild(renderer.domElement);

    // Add OrbitControls for mouse interaction
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.8;
    controls.enableZoom = true;
    controls.minDistance = 2.5;
    controls.maxDistance = 8;
    controls.enablePan = false;
    controls.target.set(0, 0, 0);

    // Enhanced lighting setup
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // Key light with shadows
    const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
    keyLight.position.set(5, 8, 5);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 1;
    keyLight.shadow.camera.far = 20;
    keyLight.shadow.camera.left = -5;
    keyLight.shadow.camera.right = 5;
    keyLight.shadow.camera.top = 5;
    keyLight.shadow.camera.bottom = -5;
    scene.add(keyLight);

    // Fill light
    const fillLight = new THREE.DirectionalLight(0xffd4a3, 0.3);
    fillLight.position.set(-3, 3, -3);
    scene.add(fillLight);

    // Rim light for edge definition
    const rimLight = new THREE.DirectionalLight(0xffffff, 0.2);
    rimLight.position.set(0, 3, -5);
    scene.add(rimLight);

    // Create main book group
    const bookGroup = new THREE.Group();
    
    // Book state
    let bookOpen = false;
    let openProgress = 0;
    const openSpeed = 0.02;

    // Create cover texture with embossed effect
    function createCoverTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');

        // Background with subtle texture
        const gradient = ctx.createLinearGradient(0, 0, 1024, 1024);
        gradient.addColorStop(0, '#345454');
        gradient.addColorStop(0.5, '#2F4F4F');
        gradient.addColorStop(1, '#264040');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 1024, 1024);

        // Add noise texture for realism
        const imageData = ctx.getImageData(0, 0, 1024, 1024);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            const noise = (Math.random() - 0.5) * 15;
            data[i] += noise;     // R
            data[i + 1] += noise; // G
            data[i + 2] += noise; // B
        }
        ctx.putImageData(imageData, 0, 0);

        // Gold border decoration
        ctx.strokeStyle = '#B8860B';
        ctx.lineWidth = 4;
        ctx.strokeRect(40, 40, 944, 944);
        
        // Inner border
        ctx.strokeStyle = '#997014';
        ctx.lineWidth = 2;
        ctx.strokeRect(60, 60, 904, 904);

        // Title with shadow for embossed effect
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        
        ctx.fillStyle = '#D4AF37'; // Brighter gold
        ctx.font = 'bold 72px Georgia, serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Title text with proper wrapping
        const lines = [
            'The Architecture',
            'of',
            'Taskusanakirja'
        ];
        
        lines.forEach((line, index) => {
            const y = 400 + (index - 1) * 100;
            ctx.fillText(line, 512, y);
            
            // Highlight effect
            ctx.shadowColor = 'rgba(255, 215, 0, 0.3)';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 1;
            ctx.strokeText(line, 512, y);
        });

        // Decorative elements
        ctx.shadowColor = 'transparent';
        ctx.fillStyle = '#B8860B';
        ctx.font = '36px Georgia, serif';
        ctx.fillText('❦', 512, 650);
        
        // Author/subtitle area
        ctx.font = 'italic 32px Georgia, serif';
        ctx.fillStyle = '#997014';
        ctx.fillText('Technical Architecture Guide', 512, 750);

        return new THREE.CanvasTexture(canvas);
    }

    // Create normal map for embossing effect
    function createNormalMap() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        
        // Base normal color (pointing straight out)
        ctx.fillStyle = '#8080ff';
        ctx.fillRect(0, 0, 1024, 1024);
        
        // Add embossed text effect areas
        ctx.strokeStyle = '#a0a0ff';
        ctx.lineWidth = 8;
        ctx.strokeRect(40, 40, 944, 944);
        
        return new THREE.CanvasTexture(canvas);
    }

    // Create roughness map
    function createRoughnessMap() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Base roughness
        ctx.fillStyle = '#808080';
        ctx.fillRect(0, 0, 512, 512);
        
        // Less rough (more shiny) where gold text is
        ctx.fillStyle = '#202020';
        ctx.font = 'bold 36px Georgia, serif';
        ctx.textAlign = 'center';
        ctx.fillText('The Architecture', 256, 200);
        ctx.fillText('of', 256, 250);
        ctx.fillText('Taskusanakirja', 256, 300);
        
        return new THREE.CanvasTexture(canvas);
    }

    // Create page texture - special content for pages 10 and 80
    function createPageTexture(pageNumber) {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 768;
        const ctx = canvas.getContext('2d');
        
        // Page background - aged paper
        const gradient = ctx.createRadialGradient(256, 384, 0, 256, 384, 400);
        gradient.addColorStop(0, '#FFF8F0');
        gradient.addColorStop(0.7, '#F7F0E3');
        gradient.addColorStop(1, '#EDE7D9');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 768);
        
        if (pageNumber === 80) {
            // Special content for page 80
            // Add decorative border
            ctx.strokeStyle = '#D4C4B0';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 20, 472, 728);
            
            // Add main text
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 48px Georgia, serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // "Product of" text
            ctx.fillText('Product of', 256, 350);
            
            // URL in larger font
            ctx.font = 'bold 56px Georgia, serif';
            ctx.fillStyle = '#7C2F3E'; // burgundy color
            ctx.fillText('siilikuin.com', 256, 420);
            
            // Add decorative element
            ctx.font = '64px Georgia, serif';
            ctx.fillStyle = '#B8860B'; // gold color
            ctx.fillText('❦', 256, 500);
            
            // Add click instruction
            ctx.font = 'bold 32px Georgia, serif';
            ctx.fillStyle = '#000000';
            ctx.fillText('Click to visit', 256, 580);
        } else if (pageNumber === 10) {
            // Page 10 - siili.png logo with white transparency
            const texture = new THREE.CanvasTexture(canvas);
            
            // Load and draw siili.png
            const img = new Image();
            img.onload = function() {
                console.log('Siili image loaded for page 10');
                
                // Clear and redraw background
                ctx.clearRect(0, 0, 512, 768);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 768);
                
                // Calculate image size maintaining aspect ratio
                const maxSize = 300; // Good size for logo
                const aspectRatio = img.width / img.height;
                let imgWidth, imgHeight;
                
                if (aspectRatio > 1) {
                    imgWidth = maxSize;
                    imgHeight = maxSize / aspectRatio;
                } else {
                    imgHeight = maxSize;
                    imgWidth = maxSize * aspectRatio;
                }
                
                // Center the image on the page
                // Shift left since part of page stays embedded in book
                const x = (512 - imgWidth) / 2 - 30; // Move left by 30 pixels
                const y = (768 - imgHeight) / 2;
                
                // Create a temporary canvas to process the image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = imgWidth;
                tempCanvas.height = imgHeight;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Draw the image to temp canvas
                tempCtx.drawImage(img, 0, 0, imgWidth, imgHeight);
                
                // Get image data and make white pixels transparent
                const imageData = tempCtx.getImageData(0, 0, imgWidth, imgHeight);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Check if pixel is white or near-white
                    if (r > 240 && g > 240 && b > 240) {
                        // Make it transparent
                        data[i + 3] = 0; // Set alpha to 0
                    }
                }
                
                // Put the modified image data back
                tempCtx.putImageData(imageData, 0, 0);
                
                // Draw the processed image to the main canvas
                ctx.drawImage(tempCanvas, x, y);
                
                // Update the texture
                texture.needsUpdate = true;
            };
            
            img.onerror = function() {
                console.error('Failed to load siili.png for page 10');
                // Fallback - just show text
                ctx.fillStyle = '#2F4F4F';
                ctx.font = 'bold 48px Georgia, serif';
                ctx.textAlign = 'center';
                ctx.fillText('Siilikuin', 256, 384);
                texture.needsUpdate = true;
            };
            
            img.src = '/siili.png';
            return texture;
        }
        // else - normal pages remain blank (no page numbers)
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        return texture;
    }
    
    let innerPageTexture = null;

    // Book dimensions
    const bookWidth = 2;
    const bookHeight = 2.8;
    const bookThickness = 0.35;
    const coverThickness = 0.03;
    const spineWidth = bookThickness + 0.05;

    // Create book cover parts
    const coverTexture = createCoverTexture();
    const normalMap = createNormalMap();
    const roughnessMap = createRoughnessMap();

    // Front cover with pivot group
    const frontCoverGeometry = new THREE.BoxGeometry(bookWidth, bookHeight, coverThickness);
    const frontCoverMaterial = new THREE.MeshStandardMaterial({
        map: coverTexture,
        normalMap: normalMap,
        normalScale: new THREE.Vector2(0.5, 0.5),
        roughnessMap: roughnessMap,
        roughness: 0.7,
        metalness: 0.1,
        bumpMap: normalMap,
        bumpScale: 0.02
    });
    const frontCoverMesh = new THREE.Mesh(frontCoverGeometry, frontCoverMaterial);
    frontCoverMesh.position.x = bookWidth / 2; // Position cover relative to pivot
    frontCoverMesh.castShadow = true;
    frontCoverMesh.receiveShadow = true;
    
    // Create pivot group for front cover at the spine
    const frontCoverPivot = new THREE.Group();
    frontCoverPivot.position.x = -bookWidth / 2;
    frontCoverPivot.position.z = bookThickness / 2;
    frontCoverPivot.add(frontCoverMesh);

    // Back cover (plain)
    const backCoverMaterial = new THREE.MeshStandardMaterial({
        color: 0x2F4F4F,
        roughness: 0.8,
        metalness: 0.05
    });
    const backCover = new THREE.Mesh(frontCoverGeometry, backCoverMaterial);
    backCover.position.z = -bookThickness / 2;
    backCover.castShadow = true;
    backCover.receiveShadow = true;

    // Spine with texture
    const spineGeometry = new THREE.BoxGeometry(spineWidth, bookHeight, bookThickness);
    const spineMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a2f2f,
        roughness: 0.6,
        metalness: 0.1
    });
    const spine = new THREE.Mesh(spineGeometry, spineMaterial);
    spine.position.x = -bookWidth / 2 - spineWidth / 2 + 0.025;
    spine.castShadow = true;
    spine.receiveShadow = true;

    // Create pages with realistic layering
    const pagesGroup = new THREE.Group();
    const pageCount = 80; // Number of visible page layers
    
    for (let i = 0; i < pageCount; i++) {
        const pageWidth = bookWidth - 0.15;
        const pageHeight = bookHeight - 0.2;
        const pageThickness = (bookThickness - coverThickness * 2) / pageCount;
        
        // Create numbered texture for ALL pages
        const pageTexture = createPageTexture(i + 1);
        
        const pageMaterial = new THREE.MeshStandardMaterial({
            map: pageTexture,
            roughness: 0.9,
            metalness: 0,
            side: THREE.DoubleSide
        });
        
        const pageGeometry = new THREE.BoxGeometry(
            pageWidth - i * 0.001, // Slightly smaller for inner pages
            pageHeight - i * 0.0005,
            pageThickness
        );
        
        const page = new THREE.Mesh(pageGeometry, pageMaterial);
        
        // Position page relative to its pivot point (left edge)
        page.position.x = (pageWidth - i * 0.001) / 2; // Half width to the right
        
        // Create pivot at the left edge of the page (binding)
        const pagePivot = new THREE.Group();
        pagePivot.position.x = -bookWidth / 2 + 0.075; // At the binding
        // Position pages slightly behind the front cover to prevent clipping
        pagePivot.position.z = -bookThickness / 2 + coverThickness * 1.5 + (i + 0.5) * pageThickness;
        pagePivot.add(page);
        
        page.castShadow = true;
        page.receiveShadow = true;
        
        // Name each page for identification
        page.name = 'page' + (i + 1);
        page.userData.pageNumber = i + 1;
        console.log('Created page', i + 1, 'at z position:', pagePivot.position.z);
        
        pagesGroup.add(pagePivot);
    }

    // Page edges (fore-edge)
    const edgeCanvas = document.createElement('canvas');
    edgeCanvas.width = 128;
    edgeCanvas.height = 512;
    const edgeCtx = edgeCanvas.getContext('2d');
    
    // Create gradient for page edges
    const edgeGradient = edgeCtx.createLinearGradient(0, 0, 128, 0);
    edgeGradient.addColorStop(0, '#F5F1E8');
    edgeGradient.addColorStop(0.5, '#EDE7D9');
    edgeGradient.addColorStop(1, '#E0D5C3');
    edgeCtx.fillStyle = edgeGradient;
    edgeCtx.fillRect(0, 0, 128, 512);
    
    // Add page lines
    edgeCtx.strokeStyle = '#D4C4B0';
    edgeCtx.lineWidth = 0.5;
    for (let i = 0; i < 512; i += 2) {
        edgeCtx.beginPath();
        edgeCtx.moveTo(0, i);
        edgeCtx.lineTo(128, i);
        edgeCtx.stroke();
    }
    
    const edgeTexture = new THREE.CanvasTexture(edgeCanvas);
    const pageHeight = bookHeight - 0.2; // Actual page height
    const pageWidth = bookWidth - 0.15; // Actual page width
    const pageThickness = bookThickness - coverThickness * 2;
    
    // Fore-edge (right side of pages)
    const foreEdgeGeometry = new THREE.PlaneGeometry(pageThickness, pageHeight);
    const foreEdgeMaterial = new THREE.MeshStandardMaterial({
        map: edgeTexture,
        roughness: 0.95,
        metalness: 0,
        side: THREE.DoubleSide
    });
    const foreEdge = new THREE.Mesh(foreEdgeGeometry, foreEdgeMaterial);
    foreEdge.rotation.y = Math.PI / 2;
    foreEdge.position.x = bookWidth / 2 - 0.075;
    foreEdge.position.z = 0;
    
    // Top and bottom page edges - must match actual page dimensions
    const topBottomEdgeGeometry = new THREE.PlaneGeometry(pageWidth, pageThickness);
    
    const topEdge = new THREE.Mesh(topBottomEdgeGeometry, foreEdgeMaterial);
    topEdge.rotation.x = Math.PI / 2;
    topEdge.position.set(-0.05, pageHeight / 2, 0);
    
    const bottomEdge = new THREE.Mesh(topBottomEdgeGeometry, foreEdgeMaterial);
    bottomEdge.rotation.x = -Math.PI / 2;
    bottomEdge.position.set(-0.05, -pageHeight / 2, 0);

    // Assemble the book (order matters for rendering)
    bookGroup.add(backCover);
    bookGroup.add(spine);
    bookGroup.add(foreEdge);
    bookGroup.add(topEdge);
    bookGroup.add(bottomEdge);
    bookGroup.add(pagesGroup);
    bookGroup.add(frontCoverPivot); // Front cover added last so it's on top when closed
    
    console.log('Book assembled with', bookGroup.children.length, 'children');


    // Position and rotate book
    bookGroup.rotation.y = -0.4;
    bookGroup.rotation.x = 0.05;
    
    // Add ground shadow plane
    const shadowGeometry = new THREE.PlaneGeometry(10, 10);
    const shadowMaterial = new THREE.ShadowMaterial({
        opacity: 0.3
    });
    const shadowPlane = new THREE.Mesh(shadowGeometry, shadowMaterial);
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.position.y = -2;
    shadowPlane.receiveShadow = true;
    scene.add(shadowPlane);

    scene.add(bookGroup);

    // Mouse interaction for book opening
    let mouseX = 0;
    let mouseY = 0;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    container.addEventListener('mousemove', (event) => {
        const rect = container.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        mouseX = mouse.x;
        mouseY = mouse.y;
        
        // Update cursor based on hover target
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(bookGroup, true);
        
        if (intersects.length > 0) {
            const firstIntersect = intersects[0];
            
            if (firstIntersect.object.name && firstIntersect.object.name.startsWith('page')) {
                container.style.cursor = 'pointer';
            } else {
                container.style.cursor = 'move';
            }
        } else {
            container.style.cursor = 'move';
        }
    });

    container.addEventListener('click', (event) => {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(bookGroup, true);
        
        if (intersects.length > 0) {
            const firstIntersect = intersects[0];
            
            // Check if clicking on a page
            if (firstIntersect.object.name && firstIntersect.object.name.startsWith('page')) {
                const pageNum = firstIntersect.object.userData.pageNumber;
                
                // Special handling for clickable pages
                if ((pageNum === 80 || pageNum === 10) && bookOpen) {
                    console.log('Opening siilikuin.com from page', pageNum);
                    window.open('https://siilikuin.com/', '_blank');
                    return;
                }
                
                // For debugging other pages
                console.log('CLICKED ON PAGE:', pageNum);
                console.log('Book is currently:', bookOpen ? 'OPEN' : 'CLOSED');
                return;
            }
            
            // Otherwise toggle book open/close
            bookOpen = !bookOpen;
            console.log('Book toggled, now:', bookOpen ? 'OPEN' : 'CLOSED');
        }
    });

    // Animation
    function animate() {
        requestAnimationFrame(animate);
        
        // Update controls
        controls.update();
        
        // Book opening animation
        if (bookOpen && openProgress < 1) {
            openProgress = Math.min(1, openProgress + openSpeed);
            if (openProgress === 1) {
                console.log('Book fully open, inner pages should be visible');
            }
        } else if (!bookOpen && openProgress > 0) {
            openProgress = Math.max(0, openProgress - openSpeed);
        }
        
        // Animate front cover opening
        frontCoverPivot.rotation.y = -openProgress * Math.PI * 0.7;
        
        // Animate some pages flipping - less rotation than cover to prevent clipping
        pagesGroup.children.forEach((pagePivot, i) => {
            if (i < 10) {
                const pageOpenDelay = i * 0.05;
                const pageOpenProgress = Math.max(0, Math.min(1, (openProgress - pageOpenDelay) * 1.2));
                // Pages rotate less than cover (0.6 vs 0.7) and with a max limit
                const maxPageRotation = Math.PI * 0.6;
                pagePivot.rotation.y = -Math.min(pageOpenProgress * maxPageRotation, maxPageRotation * 0.95);
            }
        });
        
        // Gentle floating animation
        if (!controls.isUserInteracting) {
            bookGroup.position.y = Math.sin(Date.now() * 0.001) * 0.03;
            bookGroup.rotation.y = -0.4 + Math.sin(Date.now() * 0.0008) * 0.05;
        }
        
        renderer.render(scene, camera);
    }

    animate();

    // Handle resize
    window.addEventListener('resize', () => {
        const newWidth = container.clientWidth;
        const newHeight = container.clientHeight;
        
        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();
        
        renderer.setSize(newWidth, newHeight);
    });

    // Hide hint after first interaction
    let hintHidden = false;
    container.addEventListener('mousedown', () => {
        if (!hintHidden) {
            const hint = document.getElementById('drag-hint');
            if (hint) {
                hint.style.transition = 'opacity 0.5s';
                hint.style.opacity = '0';
                setTimeout(() => hint.style.display = 'none', 500);
                hintHidden = true;
            }
        }
    });

    console.log('Enhanced 3D book successfully initialized');
    } catch (error) {
        console.error('Error initializing 3D book:', error);
        console.error('Stack trace:', error.stack);
    }
}

// Wait for DOM to be ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM loaded, initializing 3D book...');
        init();
    });
} else {
    console.log('DOM already loaded, initializing 3D book...');
    init();
}
</script>

{{ end }}